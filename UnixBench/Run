#!/usr/bin/perl -w

# 启用了 Perl 的 strict 模式，它强制执行一些编码标准，帮助捕获一些潜在的错误或者不良的编码习惯
use strict;

# POSIX 模块提供了与操作系统相关的函数，这里用于格式化日期和时间
use POSIX qw(strftime);
# Time::HiRes 模块提供了高分辨率的时间函数，允许对时间进行更精确的操作
use Time::HiRes;
# IO::Handle 模块提供了文件句柄的功能，用于进行文件输入输出
use IO::Handle;
# File::Path 模块提供了处理文件路径的功能
use File::Path;
# FindBin 模块用于查找脚本的目录
use FindBin;


############################################################################
#  UnixBench - Release 5.1.3, based on:
#  The BYTE UNIX Benchmarks - Release 3
#          Module: Run   SID: 3.11 5/15/91 19:30:14
# Original Byte benchmarks written by:
#       Ben Smith,              Tom Yager at BYTE Magazine
#       ben@bytepb.byte.com     tyager@bytepb.byte.com
# BIX:  bensmith                tyager
#
#######################################################################
# General Purpose Benchmark
# based on the work by Ken McDonell, Computer Science, Monash University
#
#  You will need ...
#       perl Time::HiRes IO::Handlecat cc chmod comm cp date dc df echo
#       kill ls make mkdir rm sed test time touch tty umask who
###############################################################################
#  Modification Log:
# $Header: run,v 5.2 88/01/12 06:23:43 kenj Exp $
#     Ken McDonell, Computer Science, Monash University
#     August 1, 1983
# 3/89 - Ben Smith - BYTE: globalized many variables, modernized syntax
# 5/89 - commented and modernized. Removed workload items till they
#        have been modernized. Added database server test.
# 11/14/89 - Made modifications to reflect new version of fstime
#        and elimination of mem tests.
# 10/22/90 - Many tests have been flipped so that they run for
#        a specified length of time and loops are counted.
# 4/3/91 - Cleaned up and debugged several test parameters - Ben
# 4/9/91 - Added structure for creating index and determing flavor of UNIX
# 4/26/91 - Made changes and corrections suggested by Tin Le of Sony
# 5/15/91 - Removed db from distribution
# 4/4/92    Jon Tombs <jon@robots.ox.ac.uk> fixed for GNU time to look like
#               BSD (don't know the format of sysV!)
# 12/95   - Massive changes for portability, speed, and more meaningful index
#               DCN     David C Niemi <niemi@tux.org>
# 1997.06.20    DCN     Fixed overflow condition in fstime.c on fast machines
# 1997.08.24    DCN     Modified "system", replaced double with
#                       whetstone-double in "index"
# 1997.09.10    DCN     Added perlbench as an Exhibition benchmark
# 1997.09.23    DCN     Added rgooch's select as an Exhibition benchmark
# 1999.07.28    DCN     "select" not compiled or run by default, because it
#                       does not compile on many platforms.  PerlBench also
#                       not run by default.
# 2007.09.26    IS      Huge rewrite -- see release notes in README.
# 2007.10.12    IS      Added graphics tests, categories feature.
# 2007.10.14    IS      Set and report LANG.  Added "grep" and "sysexec".
# 2007.12.22    IS      Tiny fixes; see README.
# 2011.01.13    KDL     Fix for parallel compilation.


############################################################################
# CONFIGURATION
############################################################################

# Version number of the script.
my $version = "5.1.3";

# The setting of LANG makes a huge difference to some of the scores,
# particularly depending on whether UTF-8 is used.  So we always set
# it to the same value, which is configured here.
#
# If you want your results to be meaningful when compared to other peoples'
# results, you should not change this.  Change it if you want to measure the
# effect of different languages.
my $language = "en_US.utf8";

# 每个测试的迭代次数
my $longIterCount = 10;
my $shortIterCount = 3;

# C compiler to use in compilation tests.
my $cCompiler = 'gcc';

# Establish full paths to directories.  These need to be full pathnames
# (or do they, any more?).  They can be set in env.
# variable names are the first parameter to getDir() below.

# 测试程序所在的目录
my $BINDIR = getDir('UB_BINDIR', $FindBin::Bin . "/pgms");

# 临时目录，用于存放临时文件
my $TMPDIR = getDir('UB_TMPDIR', $FindBin::Bin . "/tmp");

# 存放结果的目录
my $RESULTDIR = getDir('UB_RESULTDIR', $FindBin::Bin . "/results");

# 执行测试的目录
my $TESTDIR = getDir('UB_TESTDIR', $FindBin::Bin . "/testdir");


############################################################################
# 测试规范
############################################################################

# 配置测试可以所属的类别
# 定义了一个哈希引用（hash reference）变量 $testCats，用于存储一组相关的测试类别信息
my $testCats = {
    'system'    => { 'name' => "System Benchmarks", 'maxCopies' => 0 },
    '2d'        => { 'name' => "2D Graphics Benchmarks", 'maxCopies' => 1 },
    '3d'        => { 'name' => "3D Graphics Benchmarks", 'maxCopies' => 1 },
    'misc'      => { 'name' => "Non-Index Benchmarks", 'maxCopies' => 0 },
};


# 定义了五个数组引用，分别用于存储不同的测试类别
my $arithmetic = [
    "arithoh", "short", "int", "long", "float", "double", "whetstone-double"
];

my $fs = [
    "fstime-w", "fstime-r", "fstime",
    "fsbuffer-w", "fsbuffer-r", "fsbuffer",
    "fsdisk-w", "fsdisk-r", "fsdisk"
];

my $oldsystem = [
    "execl", "fstime", "fsbuffer", "fsdisk", "pipe", "context1", "spawn",
    "syscall"
];

my $system = [
    # @$oldsystem：这里使用了数组解引用，将 $oldsystem 数组中的元素展开
    @$oldsystem, "shell1", "shell8", "shell16"
];

my $index = [
   "dhry2reg", "whetstone-double", @$oldsystem, "shell1", "shell8"
];

my $graphics = [
    "2d-rects", "2d-ellipse", "2d-aashapes", "2d-text", "2d-blit",
    "2d-window", "ubgears"
];


# List of all supported test names.
my $testList = {
    # Individual tests.
    # 每一行都包含一个键值对，表示一个单独的测试。键是测试的名称，而值为 undef 表示这个测试还没有具体的信息
    "dhry2reg"      => undef,
    "whetstone-double"   => undef,
    "syscall"       => undef,
    "pipe"          => undef,
    "context1"      => undef,
    "spawn"         => undef,
    "execl"         => undef,
    "fstime-w"      => undef,
    "fstime-r"      => undef,
    "fstime"        => undef,
    "fsbuffer-w"    => undef,
    "fsbuffer-r"    => undef,
    "fsbuffer"      => undef,
    "fsdisk-w"      => undef,
    "fsdisk-r"      => undef,
    "fsdisk"        => undef,
    "shell1"        => undef,
    "shell8"        => undef,
    "shell16"       => undef,
    "short"         => undef,
    "int"           => undef,
    "long"          => undef,
    "float"         => undef,
    "double"        => undef,
    "arithoh"       => undef,
    "C"             => undef,
    "dc"            => undef,
    "hanoi"         => undef,
    "grep"          => undef,
    "sysexec"       => undef,

    "2d-rects"      => undef,
    "2d-lines"      => undef,
    "2d-circle"     => undef,
    "2d-ellipse"    => undef,
    "2d-shapes"     => undef,
    "2d-aashapes"   => undef,
    "2d-polys"      => undef,
    "2d-text"       => undef,
    "2d-blit"       => undef,
    "2d-window"     => undef,

    "ubgears"       => undef,

    # Named combos and shorthands.
    "arithmetic"    => $arithmetic,
    "dhry"          => [ "dhry2reg" ],
    "dhrystone"     => [ "dhry2reg" ],
    "whets"         => [ "whetstone-double" ],
    "whetstone"     => [ "whetstone-double" ],
    "load"          => [ "shell" ],
    "misc"          => [ "C", "dc", "hanoi" ],
    "speed"         => [ @$arithmetic, @$system ],
    "oldsystem"     => $oldsystem,
    "system"        => $system,
    "fs"            => $fs,
    "shell"         => [ "shell1", "shell8", "shell16" ],
    "graphics"      => $graphics,

    # The tests which constitute the official index.
    "index"         => $index,

    # The tests which constitute the official index plus the graphics
    # index.
    "gindex"         => [ @$index, @$graphics ],
};


# Default parameters for benchmarks.  Note that if "prog" is used,
# it must contain just the program name, as it will be quoted (this
# is necessary if BINDIR contains spaces).  Put any options in "options".
# 声明一个哈希引用变量 $baseParams，用于存储基准测试的默认参数
my $baseParams = {
    # 默认值为 undef，即没有特定的程序名称
    "prog" => undef,
    # 指定了一个键为 "options" 的项，其值为空字符串。这是用于存储基准测试选项的地方
    "options" => "",
    # 用于指定基准测试的重复次数，默认设置为 "short"
    "repeat" => 'short',
    # 表示是否保留标准输出。非零值表示保留标准输出
    "stdout" => 1,                  # Non-0 to keep stdout.
    # 用于存储基准测试的标准输入内容
    "stdin" => "",
    # 用于存储基准测试的日志消息
    "logmsg" => "",
};


# 定义了一个哈希引用变量 $testParams，其中包含了各种不同基准测试的详细参数
my $testParams = {

    ##########################
    ## System Benchmarks    ##
    ##########################

    "dhry2reg" => {
        "logmsg" => "Dhrystone 2 using register variables",
        "cat"    => 'system',
        "options" => "10",
        "repeat" => 'long',
    },
    "whetstone-double" => {
        "logmsg" => "Double-Precision Whetstone",
        "cat"    => 'system',
        "repeat" => 'long',
    },
    "syscall" => {
        "logmsg" => "System Call Overhead",
        "cat"    => 'system',
        "repeat" => 'long',
        "options" => "10",
    },
    "context1" => {
        "logmsg" => "Pipe-based Context Switching",
        "cat"    => 'system',
        "repeat" => 'long',
        "options" => "10",
    },
    "pipe" => {
        "logmsg" => "Pipe Throughput",
        "cat"    => 'system',
        "repeat" => 'long',
        "options" => "10",
    },
    "spawn" => {
        "logmsg" => "Process Creation",
        "cat"    => 'system',
        "options" => "30",
    },
    "execl" => {
        "logmsg" => "Execl Throughput",
        "cat"    => 'system',
        "options" => "30",
    },
    "fstime-w" => {
        "logmsg" => "File Write 1024 bufsize 2000 maxblocks",
        "cat"    => 'system',
        "prog" => "${BINDIR}/fstime",
        "options" => "-w -t 30 -d \"${TMPDIR}\" -b 1024 -m 2000",
    },
    "fstime-r" => {
        "logmsg" => "File Read 1024 bufsize 2000 maxblocks",
        "cat"    => 'system',
        "prog" => "${BINDIR}/fstime",
        "options" => "-r -t 30 -d \"${TMPDIR}\" -b 1024 -m 2000",
    },
   "fstime" => {
        "logmsg" => "File Copy 1024 bufsize 2000 maxblocks",
        "cat"    => 'system',
        "prog" => "${BINDIR}/fstime",
        "options" => "-c -t 30 -d \"${TMPDIR}\" -b 1024 -m 2000",
    },
    "fsbuffer-w" => {
        "logmsg" => "File Write 256 bufsize 500 maxblocks",
        "cat"    => 'system',
        "prog" => "${BINDIR}/fstime",
        "options" => "-w -t 30 -d \"${TMPDIR}\" -b 256 -m 500",
    },
    "fsbuffer-r" => {
        "logmsg" => "File Read 256 bufsize 500 maxblocks",
        "cat"    => 'system',
        "prog" => "${BINDIR}/fstime",
        "options" => "-r -t 30 -d \"${TMPDIR}\" -b 256 -m 500",
    },
    "fsbuffer" => {
        "logmsg" => "File Copy 256 bufsize 500 maxblocks",
        "cat"    => 'system',
        "prog" => "${BINDIR}/fstime",
        "options" => "-c -t 30 -d \"${TMPDIR}\" -b 256 -m 500",
    },
    "fsdisk-w" => {
        "logmsg" => "File Write 4096 bufsize 8000 maxblocks",
        "cat"    => 'system',
        "prog" => "${BINDIR}/fstime",
        "options" => "-w -t 30 -d \"${TMPDIR}\" -b 4096 -m 8000",
    },
    "fsdisk-r" => {
        "logmsg" => "File Read 4096 bufsize 8000 maxblocks",
        "cat"    => 'system',
        "prog" => "${BINDIR}/fstime",
        "options" => "-r -t 30 -d \"${TMPDIR}\" -b 4096 -m 8000",
    },
    "fsdisk" => {
        "logmsg" => "File Copy 4096 bufsize 8000 maxblocks",
        "cat"    => 'system',
        "prog" => "${BINDIR}/fstime",
        "options" => "-c -t 30 -d \"${TMPDIR}\" -b 4096 -m 8000",
    },
    "shell1" => {
        "logmsg" => "Shell Scripts (1 concurrent)",
        "cat"    => 'system',
        "prog" => "${BINDIR}/looper",
        "options" => "60 \"${BINDIR}/multi.sh\" 1",
    },
    "shell8" => {
        "logmsg" => "Shell Scripts (8 concurrent)",
        "cat"    => 'system',
        "prog" => "${BINDIR}/looper",
        "options" => "60 \"${BINDIR}/multi.sh\" 8",
    },
    "shell16" => {
        "logmsg" => "Shell Scripts (16 concurrent)",
        "cat"    => 'system',
        "prog" => "${BINDIR}/looper",
        "options" => "60 \"${BINDIR}/multi.sh\" 16",
    },

    ##########################
    ## Graphics Benchmarks  ##
    ##########################

    "2d-rects" => {
        "logmsg" => "2D graphics: rectangles",
        "cat"    => '2d',
        "prog" => "${BINDIR}/gfx-x11",
        "options" => "rects 3 2",
    },

    "2d-lines" => {
        "logmsg" => "2D graphics: lines",
        "cat"    => '2d',
        "prog" => "${BINDIR}/gfx-x11",
        "options" => "lines 3 2",
    },

    "2d-circle" => {
        "logmsg" => "2D graphics: circles",
        "cat"    => '2d',
        "prog" => "${BINDIR}/gfx-x11",
        "options" => "circle 3 2",
    },

    "2d-ellipse" => {
        "logmsg" => "2D graphics: ellipses",
        "cat"    => '2d',
        "prog" => "${BINDIR}/gfx-x11",
        "options" => "ellipse 3 2",
    },

    "2d-shapes" => {
        "logmsg" => "2D graphics: polygons",
        "cat"    => '2d',
        "prog" => "${BINDIR}/gfx-x11",
        "options" => "shapes 3 2",
    },

    "2d-aashapes" => {
        "logmsg" => "2D graphics: aa polygons",
        "cat"    => '2d',
        "prog" => "${BINDIR}/gfx-x11",
        "options" => "aashapes 3 2",
    },

    "2d-polys" => {
        "logmsg" => "2D graphics: complex polygons",
        "cat"    => '2d',
        "prog" => "${BINDIR}/gfx-x11",
        "options" => "polys 3 2",
    },

    "2d-text" => {
        "logmsg" => "2D graphics: text",
        "cat"    => '2d',
        "prog" => "${BINDIR}/gfx-x11",
        "options" => "text 3 2",
    },

    "2d-blit" => {
        "logmsg" => "2D graphics: images and blits",
        "cat"    => '2d',
        "prog" => "${BINDIR}/gfx-x11",
        "options" => "blit 3 2",
    },

    "2d-window" => {
        "logmsg" => "2D graphics: windows",
        "cat"    => '2d',
        "prog" => "${BINDIR}/gfx-x11",
        "options" => "window 3 2",
    },

    "ubgears" => {
        "logmsg" => "3D graphics: gears",
        "cat"    => '3d',
        "options" => "-time 20 -v",
    },


    ##########################
    ## Non-Index Benchmarks ##
    ##########################

    "C" => {
        "logmsg" => "C Compiler Throughput ($cCompiler)",
        "cat"    => 'misc',
        "prog" => "${BINDIR}/looper",
        "options" => "60 $cCompiler cctest.c",
    },
    "arithoh" => {
        "logmsg" => "Arithoh",
        "cat"    => 'misc',
        "options" => "10",
    },
    "short" => {
        "logmsg" => "Arithmetic Test (short)",
        "cat"    => 'misc',
        "options" => "10",
    },
    "int" => {
        "logmsg" => "Arithmetic Test (int)",
        "cat"    => 'misc',
        "options" => "10",
    },
    "long" => {
        "logmsg" => "Arithmetic Test (long)",
        "cat"    => 'misc',
        "options" => "10",
    },
    "float" => {
        "logmsg" => "Arithmetic Test (float)",
        "cat"    => 'misc',
        "options" => "10",
    },
    "double" => {
        "logmsg" => "Arithmetic Test (double)",
        "cat"    => 'misc',
        "options" => "10",
    },
    "dc" => {
        "logmsg" => "Dc: sqrt(2) to 99 decimal places",
        "cat"    => 'misc',
        "prog" => "${BINDIR}/looper",
        "options" => "30 dc",
        "stdin" => "dc.dat",
    },
    "hanoi" => {
        "logmsg" => "Recursion Test -- Tower of Hanoi",
        "cat"    => 'misc',
        "options" => "20",
    },
    "grep" => {
        "logmsg" => "Grep a large file (system's grep)",
        "cat"    => 'misc',
        "prog" => "${BINDIR}/looper",
        "options" => "30 grep -c gimp large.txt",
    },
    "sysexec" => {
        "logmsg" => "Exec System Call Overhead",
        "cat"    => 'misc',
        "repeat" => 'long',
        "prog" => "${BINDIR}/syscall",
        "options" => "10 exec",
    },
};


# CPU flags of interest.
# 定义了一个哈希引用变量 $x86CpuFlags，用于存储 x86 架构中一些与 CPU 相关的标志信息
my $x86CpuFlags = {
    'pae' => "Physical Address Ext",
    'sep' => "SYSENTER/SYSEXIT",
    'syscall' => "SYSCALL/SYSRET",
    'mmx' => "MMX",
    'mmxext' => "AMD MMX",
    'cxmmx' => "Cyrix MMX",
    'xmm' => "Streaming SIMD",
    'xmm2' => "Streaming SIMD-2",
    'xmm3' => "Streaming SIMD-3",
    'ht' => "Hyper-Threading",
    'ia64' => "IA-64 processor",
    'lm' => "x86-64",
    'vmx' => "Intel virtualization",
    'svm' => "AMD virtualization",
};


############################################################################
# UTILITIES
############################################################################

# Exec the given command, and catch its standard output.
# We return an array containing the PID and the filehandle on the
# process' standard output.  It's up to the caller to wait for the command
# to terminate.
# 定义了一个名为 command 的子例程，用于执行给定的命令并捕获其标准输出
sub command {
    # @_ 是一个特殊的数组，包含了传递给当前子例程的参数列表
    # my ( $cmd ) 是一种 Perl 中的解构语法，它将数组 @_ 中的第一个元素（即传递给子例程的命令字符串）赋值给变量 $cmd
    my ( $cmd ) = @_;

    my $pid = open(my $childFd, "-|");
    if (!defined($pid)) {
        die("Run: fork() failed (undef)\n");
    } elsif ($pid == 0) {
        exec($cmd);
        die("Run: exec() failed (returned)\n");
    }

    return ( $pid, $childFd );
}


# Get data from running a system command.  Used for things like getting
# the host OS from `uname -o` etc.
#
# Ignores initial blank lines from the command and returns the first
# non-blank line, with white space trimmed off.  Returns a blank string
# if there is no output; undef if the command fails.
# 定义了一个名为 getCmdOutput 的子例程，用于运行系统命令并获取其输出
sub getCmdOutput {
    my ( $cmd ) = @_;

    my ( $pid, $fd ) = command($cmd . " 2>/dev/null");
    my $result = "";
    while (<$fd>) {
        chomp;
        next if /^[ \t]*$/;

        $result = $_;
        $result =~ s/^[ \t]+//;
        $result =~ s/[ \t]+$//;
        last;
    }

    # Close the command and wait for it to die.
    waitpid($pid, 0);
    my $status = $?;

    return $status == 0 ? $result : undef;
}


# Get a directory pathname from an environment variable, or the given
# default.  Canonicalise and return the value.
# 定义了一个名为 getDir 的子例程，用于获取一个目录路径名，该路径名来自环境变量，如果环境变量未设置，
# 则使用给定的默认值。然后，对路径进行规范化（Canonicalise）并返回其值
sub getDir {
    my ( $var, $def ) = @_;

    # If Environment variables(e.g. UB_RESULTDIR) is unset, use default value.
    my $val = $ENV{$var} || $def;

    # Only "execl.c" test needs the Environment variable(UB_BINDIR).
    $ENV{$var} = $val;

    return $val;
}

# Create direcotry(0755) if not exists.
# 用于检查给定的目录路径是否存在，如果不存在则创建目录
sub createDirrectoriesIfNotExists {
    foreach my $path (@_) {
        my $isDirectoryNotExists = ! -d $path;
        if ( $isDirectoryNotExists ) {
            mkpath($path, {chmod => 0755});
        }
    }
}

# Show use directories.
# 用于在标准输出上打印一些使用目录的信息
sub printUsingDirectories {
    printf "------------------------------------------------------------------------------\n";
    printf "   Use directories for:\n";
    printf "      * File I/O tests (named fs***) = ${TMPDIR}\n";
    printf "      * Results                      = ${RESULTDIR}\n";
    printf "------------------------------------------------------------------------------\n";
    printf "\n";
}


# Get the name of the file we're going to log to.  The name uses the hostname
# and date, plus a sequence number to make it unique.
# 用于获取将要记录到的文件的名称。文件名基于主机名、日期以及一个序列号以确保唯一性
sub logFile {
    my ( $sysInfo ) = @_;

    # If supplied output file name via Environment variable(UB_OUTPUT_FILE_NAME), then use it.
    #   * If exists same file, it will be overwrite completly.
    my $output_file_name_supplied_by_environment = $ENV{"UB_OUTPUT_FILE_NAME"};
    if ( defined($output_file_name_supplied_by_environment) && $output_file_name_supplied_by_environment ne "" ) {
        return ${RESULTDIR} . "/" . $output_file_name_supplied_by_environment;
    }


    # Use the date in the base file name.
    my $ymd = strftime "%Y-%m-%d", localtime;

    my $count = 1;
    while (1) {
        my $log = sprintf "%s/%s-%s-%02d",
                        ${RESULTDIR}, $sysInfo->{'name'}, $ymd, $count;
        return $log if (! -e $log);
        ++$count;
    }
}


# Print a message to the named log file.  We use this method rather than
# keeping the FD open because we use shell redirection to send command
# output to the same file.
# 用于向指定的日志文件打印消息。与保持文件描述符打开不同，此方法使用文件追加模式，
# 因为我们使用 shell 重定向将命令输出发送到同一文件
sub printLog {
    my ( $logFile, @args ) = @_;

    open(my $fd, ">>", $logFile) || abortRun("can't append to $logFile");
    printf $fd @args;
    close($fd);
}


# Display a number of something, auto-selecting the plural form
# if appropriate.  We are given the number, the singular, and the
# plural; if the plural is omitted, it defaults to singular + "s".
# 用于显示数量的信息，根据数量自动选择单数或复数形式
sub number {
    my ( $n, $what, $plural ) = @_;

    $plural = $what . "s" if !defined($plural);

    if (!defined($n)) {
        return sprintf "unknown %s", $plural;
    } else {
        return sprintf "%d %s", $n, $n == 1 ? $what : $plural;
    }
}


# Merge two sets of test parameters -- defaults and actual parameters.
# Return the merged parameter hash.
# 用于合并两个哈希引用，其中一个是默认参数，另一个是用户提供的参数
sub mergeParams {
    my ( $def, $vals ) = @_;

    my $params = { };
    foreach my $k (keys(%$def)) {
        $params->{$k} = $def->{$k};
    }
    foreach my $k (keys(%$vals)) {
        $params->{$k} = $vals->{$k};
    }

    $params;
}


############################################################################
# 系统分析
############################################################################

# Extract interesting flags from the given processor flags string and
# convert them to descriptive names.
# 用于从给定的处理器标志字符串中提取感兴趣的标志，并将它们转换为描述性的名称
sub processCpuFlags {
    my ( $flagStr ) = @_;

    my @names;
    foreach my $f (sort split(/\s+/, $flagStr)) {
        my $name = $x86CpuFlags->{$f};
        push(@names, $name) if $name;
    }

    join(", ", @names);
}


# Get information on the CPUs in the system.  Returns a reference to an
# array of N entries, one per CPU, where each entry is a hash containing
# these fields:
# describing the model etc.  Returns undef if the information can't be got.
#
# future: on systems without /proc/cpuinfo, might check for Perl modules:
#   Sys::Info::Device::CPU or Sys::CpuAffinity
# 用于获取系统中的CPU信息
sub getCpuInfo {
    if (!("$^O" eq "darwin")) {
        open(my $fd, "<", "/proc/cpuinfo") || return undef;

        my $cpus = [ ];
        my $cpu = 0;
        while (<$fd>) {
            chomp;
            my ( $field, $val ) = split(/[ \t]*:[ \t]*/);
            next if (!$field || !$val);
            if ($field eq "processor") {
                $cpu = $val;
            } elsif ($field eq "model name") {
                my $model = $val;
                $model =~ s/  +/ /g;
                $cpus->[$cpu]{'model'} = $model;
            } elsif ($field eq "bogomips" || $field eq "BogoMIPS") {
                $cpus->[$cpu]{'bogo'} = $val;
            } elsif ($field eq "flags") {
                $cpus->[$cpu]{'flags'} = processCpuFlags($val);
            }
        }

        close($fd);

        $cpus;

    } else {

        my $model = getCmdOutput("sysctl -n machdep.cpu.brand_string");
        my $flags = getCmdOutput("sysctl -n machdep.cpu.features | tr [A-Z] [a-z]");
        my $ncpu  = getCmdOutput("sysctl -n hw.ncpu");

        my $cpus = [ ];
        my $cpu = 0;

        for ($cpu = 0; $cpu < $ncpu; $cpu++) {
            $cpus->[$cpu]{'model'} = $model;
            $cpus->[$cpu]{'bogo'}  = 0;
            $cpus->[$cpu]{'flags'} = processCpuFlags($flags);
        }
        $cpus;
    }
}


# Get number of available (active) CPUs (not including disabled CPUs)
# or, if not num of available CPUs, the total number of CPUs on the system
# Returns undef if the information can't be obtained.
#
# There is no shortage of platform-specific methods to obtain this info.
# This routine -is not- exhaustive, but adds some additional portability.
# Most modern unix systems implement sysconf(_SC_NPROCESSORS_ONLN).
# 用于获取系统中的可用（活动）CPU数量或系统中的总CPU数量
sub getNumActiveCpus {
    my $numCpus;

    #(POSIX::_SC_NPROCESSORS_ONLN value not typically provided by POSIX.pm)
    #$numCpus = POSIX::sysconf(POSIX::_SC_NPROCESSORS_ONLN);
    #if (defined($numCpus)) { chomp $numCpus; return $numCpus if $numCpus; }

    $numCpus = `getconf _NPROCESSORS_ONLN 2>/dev/null`;
    if (defined($numCpus)) { chomp $numCpus; return $numCpus if $numCpus; }

    $numCpus = `getconf NPROCESSORS_ONLN 2>/dev/null`;
    if (defined($numCpus)) { chomp $numCpus; return $numCpus if $numCpus; }

    $numCpus = `nproc 2>/dev/null`;
    if (defined($numCpus)) { chomp $numCpus; return $numCpus if $numCpus; }

    $numCpus = `python -c 'import os; print os.sysconf(os.sysconf_names["SC_NPROCESSORS_ONLN"]);' 2>/dev/null`;
    if (defined($numCpus)) { chomp $numCpus; return $numCpus if $numCpus; }

    # Windows
    return $ENV{"NUMBER_OF_PROCESSORS"} if $ENV{"NUMBER_OF_PROCESSORS"};

    return undef;
}


# Get information on the host system.  Returns a reference to a hash
# with the following fields:
#    name           Host name
#    os             Host OS name
#    osRel          Host OS release
#    osVer          Host OS version
#    mach           Host machine name (eg. "SparcStation 20", but on
#                   PC/Linux usually "i686" etc.)
#    platform       Hardware platform; on Linux, the base CPU type?
#    system         System name (eg. hostname and Linux distro, like
#                   "hostname: openSUSE 10.2 (i586)").
#    cpus           Value returned by getCpuInfo(), undef if not avail.
#    numCpus        Number of CPUs if known, else undef.
#    load           System load message as per "uptime".
#    numUsers       Number of users and/or open shell sessions.
# 用于获取主机系统的信息
sub getSystemInfo {
    my $info = { };

    # Get host system data.
    $info->{'name'} = getCmdOutput("hostname");
    $info->{'os'} = getCmdOutput("uname -o") || getCmdOutput("uname -s");
    $info->{'osRel'} = getCmdOutput("uname -r");
    $info->{'osVer'} = getCmdOutput("uname -v");
    $info->{'mach'} = $^O ne "aix"
      ? getCmdOutput("uname -m")
      : getCmdOutput("uname -p");
    $info->{'platform'} = getCmdOutput("uname -i") || "unknown";

    # Get the system name (SUSE, Red Hat, etc.) if possible.
    $info->{'system'} = $info->{'os'};
    if ( -r "/etc/SuSE-release" ) {
        $info->{'system'} = getCmdOutput("cat /etc/SuSE-release");
    } elsif ( -r "/etc/release" ) {
        $info->{'system'} = getCmdOutput("cat /etc/release");
    }

    # Get the language info.
    my $lang = getCmdOutput("printenv LANG");
    my $map = $^O ne "aix"
      ? getCmdOutput("locale -k LC_CTYPE | grep charmap") || ""
      : getCmdOutput("locale charmap") || "";
    $map =~ s/.*=//;
    my $coll = $^O ne "aix"
      ? getCmdOutput("locale -k LC_COLLATE | grep collate-codeset") || ""
      : getCmdOutput("locale | grep LC_COLLATE") || "";
    $coll =~ s/.*=//;
    $info->{'language'} = sprintf "%s (charmap=%s, collate=%s)",
                                   $lang, $map, $coll;

    # Get details on the CPUs, if possible.
    my $cpus = getCpuInfo();
    if (defined($cpus)) {
        $info->{'cpus'} = $cpus;
        $info->{'numCpus'} = scalar(@$cpus);
    }

    # Get available number of CPUs (not disabled CPUs), if possible.
    my $numCpus = getNumActiveCpus();
    if (defined($numCpus)) {
        $info->{'numCpus'} = $numCpus; # overwrite value from getCpuinfo()
    }

    # Get graphics hardware info.
    $info->{'graphics'} = getCmdOutput("3dinfo | cut -f1 -d\'(\'");

    # Get system run state, load and usage info.
    $info->{'runlevel'} = getCmdOutput("who -r | awk '{print \$3}'");
    $info->{'load'} = getCmdOutput("uptime");
    $info->{'numUsers'} = getCmdOutput("who | wc -l");

    $info;
}


############################################################################
# ERROR HANDLING
############################################################################

# Abort the benchmarking run with an error message.
# 用于在发生错误时中止基准运行
sub abortRun {
    my ( $err ) = @_;

    printf STDERR "\n**********************************************\n";
    printf STDERR "Run: %s; aborting\n", $err;
    exit(1);
}


############################################################################
# TEST SETUP
############################################################################

# Do checks that everything's ready for testing.
# 用于执行在测试之前的一些准备检查
sub preChecks {
    # Set the language.
    $ENV{'LANG'} = $language;

    # Check that the required files are in the proper places.
    my $make = $ENV{MAKE} || "make";
    system("$make check");
    if ($? != 0) {
        system("$make all");
        if ($? != 0) {
            abortRun("\"$make all\" failed");
        }
    }

    # Create a script to kill this run.
    system("echo \"kill -9 $$\" > \"${TMPDIR}/kill_run\"");
    chmod(0755, $TMPDIR . "/kill_run");
}


# Parse the command arguments.
# 用于解析命令行参数
sub parseArgs {
    my @words = @_;

    # The accumulator for the bench units to be run.
    # 用于存储要运行的基准测试单元的累加器
    my $tests = [ ];
    my $params = { 'tests' => $tests };

    # 生成请求的基准程序列表
    my $opt;
    my $word;
    while ($word = shift(@words)) {
        # 如果单词不以"-"开头，则将其视为测试名称
        if ($word !~ m/^-/) {               # A test name.
            # 如果单词是 "all"，则将所有测试添加到列表中
            if ($word eq "all") {
                foreach my $t (keys(%$testList)) {
                    push(@$tests, $t) if (!defined($testList->{$t}));
                }
            # 如果单词在测试列表中，则添加相应的测试
            } elsif (exists($testList->{$word})) {
                my $val = $testList->{$word} || [ $word ];
                push(@$tests, @$val);
            # 如果单词既不是 "all" 也不在测试列表中，则引发错误
            } else {
                die("Run: unknown test \"$word\"\n");
            }
        # 如果单词以"-"开头，则将其处理为选项
        } elsif ($word eq "-q") {
            # 如果选项是 "-q"，将详细程度设置为 0（静默模式）
            $params->{'verbose'} = 0;
        } elsif ($word eq "-v") {
            # 如果选项是 "-v"，将详细程度设置为 2（详细模式）
            $params->{'verbose'} = 2;
        } elsif ($word eq "-i") {
            # 如果选项是 "-i"，将迭代次数设置为下一个单词
            $params->{'iterations'} = shift(@words);
        } elsif ($word eq "-c") {
            # 如果选项是 "-c"，初始化 'copies' 数组并添加下一个单词
            if (!defined($params->{'copies'})) {
                $params->{'copies'} = [ ];
            }
            push(@{$params->{'copies'}}, shift(@words));
        # 如果单词以"-"开头，且无法识别为选项，则引发错误
        } else {
            die("Run: unknown option $word\n");
        }
    }

    # 返回解析后的参数
    $params;
}


############################################################################
# RESULTS INPUT / OUTPUT
############################################################################

# Read a set of benchmarking results from the given file.
# Returns results in the form returned by runTests(), but without the
# individual pass results.
# 从文件中读取基准测试的结果，以哈希表的形式返回，其中键是基准测试的名称，而值是该基准测试的结果
sub readResultsFromFile {
    my ( $file ) = @_;

    # Attempt to get the baseline data file; if we can't, just return undef.
    open(my $fd, "<", $file) || return undef;

    my $results = { };
    while (<$fd>) {
        chomp;

        # Dump comments, ignore blank lines.
        s/#.*//;
        next if /^\s*$/;

        my ( $name, $time, $slab, $sum, $score, $iters ) = split(/\|/);
        my $bresult = { };
        $bresult->{'score'} = $score;
        $bresult->{'scorelabel'} = $slab;
        $bresult->{'time'} = $time;
        $bresult->{'iterations'} = $iters;

        $results->{$name} = $bresult;
    }

    close($fd);

    $results;
}


############################################################################
# RESULTS PROCESSING
############################################################################

# Process a set of results from a single test by averaging the individal
# pass results into a single final value.
# First, though, dump the worst 1/3 of the scores.  The logic is that a
# glitch in the system (background process waking up, for example) may
# make one or two runs go slow, so let's discard those.
#
# $bresult is a hashed array representing the results of a single test;
# $bresult->{'passes'} is an array of the output from the individual
# passes.
# 用于处理单个测试的结果，通过将各个单独的测试通过结果平均为一个最终值
sub combinePassResults {
    my ( $bench, $tdata, $bresult, $logFile ) = @_;

    $bresult->{'cat'} = $tdata->{'cat'};

    # Computed results.
    my $iterations = 0;
    my $totalTime = 0;
    my $sum = 0;
    my $product = 0;
    my $label;

    my $pres = $bresult->{'passes'};

    # We're going to throw away the worst 1/3 of the pass results.
    # Figure out how many to keep.
    my $npasses = scalar(@$pres);
    my $ndump = int($npasses / 3);

    foreach my $presult (sort { $a->{'COUNT0'} <=> $b->{'COUNT0'} } @$pres) {
        my $count = $presult->{'COUNT0'};
        my $timebase = $presult->{'COUNT1'};
        $label = $presult->{'COUNT2'};
        my $time = $presult->{'TIME'} || $presult->{'elapsed'};

        # Skip this result if it's one of the worst ones.
        if ($ndump > 0) {
            printLog($logFile, "*Dump score: %12.1f\n", $count);
            --$ndump;
            next;
        }

        # Count this result.
        ++$iterations;
        printLog($logFile, "Count score: %12.1f\n", $count);

        # If $timebase is 0 the figure is a rate; else compute
        # counts per $timebase.  $time is always seconds.
        if ($timebase > 0 && $time > 0) {
            $sum += $count / ($time / $timebase);
            $product += log($count) - log($time / $timebase) if ($count > 0);
        } else {
            $sum += $count;
            $product += log($count) if ($count > 0);
        }
        $totalTime += $time;
    }

    # Save the results for the benchmark.
    if ($iterations > 0) {
        $bresult->{'score'} = exp($product / $iterations);
        $bresult->{'scorelabel'} = $label;
        $bresult->{'time'} = $totalTime / $iterations;
        $bresult->{'iterations'} = $iterations;
    } else {
        $bresult->{'error'} = "No measured results";
    }
}


# Index the given full benchmark results against the baseline results.
# $results is a hashed array of test names to test results.
#
# Adds the following fields to each benchmark result:
#    iscore         The baseline score for this test
#    index          The index of this test against the baseline
# Adds the following fields to $results:
#    indexed        The number of tests for which index values were
#                   generated
#    fullindex      Non-0 if all the index tests were indexed
#    index          The computed overall index for the run
# Note that the index values are computed as
#    result / baseline * 10
# so an index of 523 indicates that a test ran 52.3 times faster than
# the baseline.
# 用于将给定的完整基准测试结果与基准线结果进行比较，并计算索引值。索引值表示测试相对于基准的性能提升倍数
sub indexResults {
    my ( $results ) = @_;

    # Read in the baseline result data.  If we can't get it, just return
    # without making indexed results.
    my $index = readResultsFromFile($BINDIR . "/index.base");
    if (!defined($index)) {
        return;
    }

    # Count the number of results we have (indexed or not) in
    # each category.
    my $numCat = { };
    foreach my $bench (@{$results->{'list'}}) {
        my $bresult = $results->{$bench};
        ++$numCat->{$bresult->{'cat'}};
    }
    $results->{'numCat'} = $numCat;

    my $numIndex = { };
    my $indexed = { };
    my $sum = { };
    foreach my $bench (sort(keys(%$index))) {
        # Get the test data for this benchmark.
        my $tdata = $testParams->{$bench};
        if (!defined($tdata)) {
            abortRun("unknown benchmark \"$bench\" in $BINDIR/index.base");
        }

        # Get the test category.  Count the total tests in this cat.
        my $cat = $tdata->{'cat'};
        ++$numIndex->{$cat};

        # If we don't have a result for this test, skip.
        next if (!defined($results->{$bench}));

        # Get the index and actual results.  Calcluate the score.
        my $iresult = $index->{$bench};
        my $bresult = $results->{$bench};
        my $ratio = $bresult->{'score'} / $iresult->{'score'};

        # Save the indexed score.
        $bresult->{'iscore'} = $iresult->{'score'};
        $bresult->{'index'} = $ratio * 10;

        # Sun the scores, and count this test for this category.
        $sum->{$cat} += log($ratio) if ($ratio > 0.000001);
        ++$indexed->{$cat};
    }

    # Calculate the index scores per category.
    $results->{'indexed'} = $indexed;
    $results->{'numIndex'} = $numIndex;
    foreach my $c (keys(%$indexed)) {
        if ($indexed->{$c} > 0) {
            $results->{'index'}{$c} = exp($sum->{$c} / $indexed->{$c}) * 10;
        }
    }
}


############################################################################
# TEST EXECUTION
############################################################################

# Exec the given command in a sub-process.
#
# In the child process, we run the command and store its standard output.
# We also time its execution, and catch its exit status.  We then write
# the command's output, plus lines containing the execution time and status,
# to a pipe.
#
# In the parent process, we immediately return an array containing the
# child PID and the filehandle to the pipe.  This allows the caller to
# kick off multiple commands in parallel, then gather their output.
# 在子进程中执行给定的命令，并通过管道传递命令的输出、执行时间和状态信息。这样可以实现并行执行多个命令
sub commandBuffered {
    my ( $cmd ) = @_;

    # 为父子通信创建管道。
    my $childReader;
    my $parentWriter;
    pipe($childReader, $parentWriter) || abortRun("pipe() failed");
    $parentWriter->autoflush(1);

    # 分叉出子进程。
    my $pid = fork();
    if (!defined($pid)) {
        abortRun("fork() failed (undef)");
    } elsif ($pid == 0) {
        # 关闭管道的另一端。
        close $childReader;

        # 启动时钟并生成命令。
        my $benchStart = Time::HiRes::time();
        my ( $cmdPid, $cmdFd ) = command($cmd);

        # 读取并缓冲所有命令的输出。
        my $output = [ ];
        while (<$cmdFd>) {
            push(@$output, $_);
        }

        # 停止时钟并保存时间。
        my $elTime = Time::HiRes::time() - $benchStart;
        push(@$output, sprintf "elapsed|%f\n", $elTime);

        # 等待子进程死亡，以获取其状态。
        # close($cmdFd);  为什么不起作用？？？
        waitpid($cmdPid, 0);
        my $status = $?;
        push(@$output, sprintf "status|%d\n", $status);

        # 现在我们已经获得了时间，可以将所有输出回放到管道。
        # 父进程可以在适当的时候读取这些内容。
        foreach my $line (@$output) {
            print $parentWriter $line;
        }

        # 终止此子进程。
        close $parentWriter;
        exit(0);
    }

    # 关闭管道的另一端。
    close $parentWriter;

    return ( $pid, $childReader );
}


# 从子进程中读取基准测试执行的结果，给定其进程ID和文件句柄。
# 创建一个包含子进程返回的字段的结果哈希结构，还包括:
#    pid            子进程的进程ID
#    status         子进程的退出状态
#    ERROR          子进程的stderr输出，不包含结果数据
# 注意，任何具有多个值的结果字段都会被拆分; 所以例如
#    COUNT|x|y|x
# 变成
#    COUNT0 = x
#    COUNT1 = y
#    COUNT2 = z
sub readResults {
    my ( $pid, $fd ) = @_;

    my $presult = { 'pid' => $pid };

    # Read all the result lines from the child.
    while (<$fd>) {
        chomp;

        my ( $field, @params ) = split(/\|/);
        if (scalar(@params) == 0) {            # Error message.
            $presult->{'ERROR'} .= "\n" if ($presult->{'ERROR'});
            $presult->{'ERROR'} .= $field;
        } elsif (scalar(@params) == 1) {       # Simple data.
            $presult->{$field} = $params[0];
        } else {                               # Compound data.
            # Store the values in separate fields, named "FIELD$i".
            for (my $x = 0; $x < scalar(@params); ++$x) {
                $presult->{$field . $x} = $params[$x];
            }
        }
    }

    # If the command had an error, make an appropriate message if we
    # don't have one.
    if ($presult->{'status'} != 0 && !defined($presult->{'ERROR'})) {
        $presult->{'ERROR'} = "command returned status " . $presult->{'status'};
    }

    # Wait for the child to die.
    close($fd);
    waitpid($pid, 0);

    $presult;
}


# 执行一个基准测试命令。 我们一次并行设置给定数量的副本以使用多个CPU。
#
# 我们返回一个结果哈希的数组，每个哈希对应一个副本; 每个副本的格式与 readResults() 返回的格式相同。
sub executeBenchmark {
    my ( $command, $copies ) = @_;

    # 保存所有运行副本的上下文数组。
    my $ctxt = [ ];

    # 同时启动所有命令。
    for (my $i = 0; $i < $copies; ++$i) {
        my ( $cmdPid, $cmdFd ) = commandBuffered($command);
        $ctxt->[$i] = {
            'pid'     => $cmdPid,
            'fd'      => $cmdFd,
        };
    }

    # 现在，我们可以按顺序读取命令的结果。因为子进程读取和缓冲结果，并计时命令，
    # 所以无需使用 select() 以获取结果的即时性。
    my $pres = [ ];
    for (my $i = 0; $i < $copies; ++$i) {
        my $presult = readResults($ctxt->[$i]{'pid'}, $ctxt->[$i]{'fd'});
        push(@$pres, $presult);
    }

    $pres;
}


# 运行一个基准测试的一个迭代，根据给定的基准测试参数。我们并行运行多个副本，数量由 $copies 指定
sub runOnePass {
    my ( $params, $verbose, $logFile, $copies ) = @_;

    # 获取要运行的命令。
    my $command = $params->{'command'};
    if ($verbose > 1) {
        printf "\n";
        printf "COMMAND: \"%s\"\n", $command;
        printf "COPIES: \"%d\"\n", $copies;
    }

    # 记住当前位置，并切换到测试目录。
    my $pwd = `pwd`;
    chdir($TESTDIR);

    # 并行执行 N 个副本的基准测试。
    my $copyResults = executeBenchmark($command, $copies);
    printLog($logFile, "\n");

    # 切回原来的目录。
    chdir($pwd);

    # 统计所有副本的分数。
    my $count = 0;
    my $time = 0;
    my $elap = 0;
    foreach my $res (@$copyResults) {
        # 记录每个副本的结果数据。
        foreach my $k (sort(keys(%$res))) {
            printLog($logFile, "# %s: %s\n", $k, $res->{$k});
        }
        printLog($logFile, "\n");

        # 如果基准测试失败，则退出。
        if (defined($res->{'ERROR'})) {
            my $name = $params->{'logmsg'};
            abortRun("\"$name\": " . $res->{'ERROR'});
        }

        # 统计分数。
        $count += $res->{'COUNT0'};
        $time += $res->{'TIME'} || $res->{'elapsed'};
        $elap += $res->{'elapsed'};
    }

    # 构建一个合并的结果。
    my $passResult = $copyResults->[0];
    $passResult->{'COUNT0'} = $count;
    $passResult->{'TIME'} = $time / $copies;
    $passResult->{'elapsed'} = $elap / $copies;

    $passResult;
}


# 运行基准测试
sub runBenchmark {
    my ( $bench, $tparams, $verbose, $logFile, $copies ) = @_;

    # 将实际的基准测试参数合并
    my $params = mergeParams($baseParams, $tparams);

    # 基于参数构建命令字符串
    my $prog = $params->{'prog'} || $BINDIR . "/" . $bench;
    my $command = sprintf "\"%s\" %s", $prog, $params->{'options'};
    $command .= " < \"" . $params->{'stdin'} . "\"" if ($params->{'stdin'});
    $command .= " 2>&1";
    $command .= $params->{'stdout'} ? (" >> \"" . $logFile . "\"") : " > /dev/null";
    $params->{'command'} = $command;

    # 设置基准测试结果结构
    my $bresult = { 'name' => $bench, 'msg' => $params->{'logmsg'} };

    if ($verbose > 0) {
        printf "\n%d x %s ", $copies, $params->{'logmsg'};
    }

    # 将基准测试信息记录到日志文件中
    printLog($logFile,
             "\n########################################################\n");
    printLog($logFile, "%s -- %s\n",
             $params->{'logmsg'}, number($copies, "copy", "copies"));
    printLog($logFile, "==> %s\n\n", $command);

    # 运行基准测试的迭代，由 "repeat" 参数给出
    my $repeats = $shortIterCount;
    $repeats = $longIterCount if $params->{'repeat'} eq 'long';
    $repeats = 1 if $params->{'repeat'} eq 'single';
    my $pres = [ ];
    for (my $i = 1; $i <= $repeats; ++$i) {
        printLog($logFile, "#### Pass %d\n\n", $i);

        # 尝试刷新缓冲区
        system("sync; sleep 1; sync; sleep 2");
        # 显示心跳
        if ($verbose > 0) {
            printf " %d", $i;
        }

        # 执行基准测试的一次迭代
        my $presult = runOnePass($params, $verbose, $logFile, $copies);
        push(@$pres, $presult);
    }
    $bresult->{'passes'} = $pres;

    # 计算该基准测试的平均结果
    combinePassResults($bench, $tparams, $bresult, $logFile);

    # 记录结果
    if ($copies == 1) {
        printLog($logFile, "\n>>>> Results of 1 copy\n");
    } else {
        printLog($logFile, "\n>>>> Sum of %d copies\n", $copies);
    }
    foreach my $k ( 'score', 'time', 'iterations' ) {
        printLog($logFile, ">>>> %s: %s\n", $k, $bresult->{$k});
    }
    printLog($logFile, "\n");

    # 一些特定的清理例程
    if ($bench eq "C") {
        unlink(${TESTDIR} . "/cctest.o");
        unlink(${TESTDIR} . "/a.out");
    }

    if ($verbose > 0) {
        printf "\n";
    }

    # 返回基准测试结果
    $bresult;
}



# 运行指定的基准测试
sub runTests {
    my ( $tests, $verbose, $logFile, $copies ) = @_;

    # 存储测试结果的哈希表，以及测试开始时间和运行的副本数
    my $results = { 'start' => time(), 'copies' => $copies };

    # 遍历所有请求的基准测试
    foreach my $bench (@$tests) {
        # 获取此基准测试的参数
        my $params = $testParams->{$bench};
        
        # 如果参数未定义，终止运行并显示错误信息
        if (!defined($params)) {
            abortRun("unknown benchmark \"$bench\"");
        }

        # 如果此基准测试不希望以这么多副本运行，跳过它
        my $cat = $params->{'cat'};
        my $maxCopies = $testCats->{$cat}{'maxCopies'};
        next if ($maxCopies > 0 && $copies > $maxCopies);

        # 运行基准测试
        my $bresult = runBenchmark($bench, $params, $verbose, $logFile, $copies);
        
        # 将基准测试结果存储在结果哈希表中
        $results->{$bench} = $bresult;
    }

    # 记录测试结束时间
    $results->{'end'} = time();

    # 生成按基准测试名称排序的列表，其中包含结果
    my @benches = grep {
        ref($results->{$_}) eq "HASH" && defined($results->{$_}{'msg'})
    } keys(%$results);
    @benches = sort {
        $results->{$a}{'msg'} cmp $results->{$b}{'msg'}
    } @benches;

    # 将排序后的基准测试列表存储在结果哈希表中
    $results->{'list'} = \@benches;

    # 生成相对于基准数据的索引分数
    indexResults($results);

    # 返回所有基准测试的结果
    $results;
}


############################################################################
# TEXT REPORTS
############################################################################

# 显示指示被测系统配置的横幅到给定的文件描述符
sub displaySystem {
    my ( $info, $fd ) = @_;

    # Display basic system info.
    printf $fd "   System: %s: %s\n", $info->{'name'}, $info->{'system'};
    printf $fd "   OS: %s -- %s -- %s\n",
                        $info->{'os'}, $info->{'osRel'}, $info->{'osVer'};
    printf $fd "   Machine: %s (%s)\n", $info->{'mach'}, $info->{'platform'};
    printf $fd "   Language: %s\n", $info->{'language'};

    # Get and display details on the CPUs, if possible.
    my $cpus = $info->{'cpus'};
    if (!defined($cpus)) {
        printf $fd "   CPU: no details available\n";
    } else {
        for (my $i = 0; $i <= $#$cpus; ++$i) {
            printf $fd "   CPU %d: %s (%.1f bogomips)\n",
                       $i, $cpus->[$i]{'model'}, $cpus->[$i]{'bogo'};
            printf $fd "          %s\n", $cpus->[$i]{'flags'};
        }
    }

    if ($info->{'graphics'}) {
        printf $fd "   Graphics: %s\n", $info->{'graphics'};
    }

    # Display system load and usage info.
    printf $fd "   %s; runlevel %s\n\n", $info->{'load'}, $info->{'runlevel'};
}


# 从给定的测试结果集中显示测试分数。
sub logResults {
    my ( $results, $outFd ) = @_;

    # Display the individual test scores.
    foreach my $bench (@{$results->{'list'}}) {
        my $bresult = $results->{$bench};

        printf $outFd "%-40s %12.1f %-5s (%.1f s, %d samples)\n",
                      $bresult->{'msg'},
                      $bresult->{'score'},
                      $bresult->{'scorelabel'},
                      $bresult->{'time'},
                      $bresult->{'iterations'};
    }

    printf $outFd "\n";
}


# 显示给定运行结果的索引分数（如果有）
sub logIndexCat {
    my ( $results, $cat, $outFd ) = @_;

    my $total = $results->{'numIndex'}{$cat};
    my $indexed = $results->{'indexed'}{$cat};
    my $iscore = $results->{'index'}{$cat};
    my $full = $total == $indexed;

    # If there are no indexed scores, just say so.
    if (!defined($indexed) || $indexed == 0) {
        printf $outFd "No index results available for %s\n\n",
                      $testCats->{$cat}{'name'};
        return;
    }

    # Display the header, depending on whether we have a full set of index
    # scores, or a partial set.
    my $head = $testCats->{$cat}{'name'} .
                        ($full ? " Index Values" : " Partial Index");
    printf $outFd "%-40s %12s %12s %8s\n",
                  $head, "BASELINE", "RESULT", "INDEX";

    # Display the individual test scores.
    foreach my $bench (@{$results->{'list'}}) {
        my $bresult = $results->{$bench};
        next if $bresult->{'cat'} ne $cat;

	if (defined($bresult->{'iscore'}) && defined($bresult->{'index'})) {
            printf $outFd "%-40s %12.1f %12.1f %8.1f\n",
                      $bresult->{'msg'}, $bresult->{'iscore'},
                      $bresult->{'score'}, $bresult->{'index'};
	} else {
            printf $outFd "%-40s %12s %12.1f %8s\n",
                      $bresult->{'msg'}, "---",
                      $bresult->{'score'}, "---";
	}
    }

    # Display the overall score.
    my $title = $testCats->{$cat}{'name'} . " Index Score";
    if (!$full) {
        $title .= " (Partial Only)";
    }
    printf $outFd "%-40s %12s %12s %8s\n", "", "", "", "========";
    printf $outFd "%-66s %8.1f\n", $title, $iscore;

    printf $outFd "\n";
}


# Display index scores, if any, for the given run results.
sub logIndex {
    my ( $results, $outFd ) = @_;

    my $count = $results->{'indexed'};
    foreach my $cat (keys(%$count)) {
        logIndexCat($results, $cat, $outFd);
    }
}


# Dump the given run results into the given report file.
sub summarizeRun {
    my ( $systemInfo, $results, $verbose, $reportFd ) = @_;

    # Display information about this test run.
    printf $reportFd "------------------------------------------------------------------------\n";
    printf $reportFd "Benchmark Run: %s %s - %s\n",
           strftime("%a %b %d %Y", localtime($results->{'start'})),
           strftime("%H:%M:%S", localtime($results->{'start'})),
           strftime("%H:%M:%S", localtime($results->{'end'}));
    printf $reportFd "%s in system; running %s of tests\n",
           number($systemInfo->{'numCpus'}, "CPU"),
           number($results->{'copies'}, "parallel copy", "parallel copies");
    printf $reportFd "\n";

    # Display the run scores.
    logResults($results, $reportFd);

    # Display the indexed scores, if any.
    logIndex($results, $reportFd);
}


# Write CSV Headers.
#   e.g.: "Concurrency,Dhrystone 2 using register variables,Double-Precision Whetstone"
#       
# 用于写入CSV文件的标题行。它在第一列写入"Concurrency"，然后在后续列中写入每个测试的名称。CSV文件的标题行以逗号分隔，表示每一列的名称
sub summarizeRunCsvHeader {
    my ( $results, $reportFd ) = @_;

    # First col is for Concurrency value.
    printf $reportFd "Concurrency";

    # Write CSV Headers of test.
    foreach my $bench (@{$results->{'list'}}) {
        my $bresult = $results->{$bench};
        printf $reportFd ",%s", $bresult->{'msg'};
    }
    printf $reportFd "\n";
}

# 按并发度写入CSV数据行，例如 "./Run -c 1 -c 2"。
#   例如: 1,33526940.9,3623.9
#         2,30386997.8,3678.8
#         4,31439797.3,3781.4
#         8,32872262.9,3826.2
sub summarizeRunCsvRows {
    my ( $results, $reportFd) = @_;

    # Write concurrency value.
    printf $reportFd "%d", $results->{'copies'};
    
    # Write test results.
    my $isFirstColumn = 1;
    foreach my $bench (@{$results->{'list'}}) {
        my $bresult = $results->{$bench};

        printf $reportFd ",%.1f", $bresult->{'score'};
        $isFirstColumn = 0;
    }

    printf $reportFd "\n";
}



############################################################################
# HTML REPORTS
############################################################################

# 此子例程用于生成 HTML 报告的头部
sub runHeaderHtml {
    my ( $systemInfo, $reportFd ) = @_;

    # Display information about this test run.
    my $title = sprintf "Benchmark of %s / %s on %s",
                     $systemInfo->{'name'}, $systemInfo->{'system'},
                     strftime("%a %b %d %Y", localtime());

    print $reportFd <<EOF;
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="keywords" content="linux, benchmarks, benchmarking">
  <title>$title</title>
  <style type="text/css">
    table {
      margin: 1em 1em 1em 0;
      background: #f9f9f9;
      border: 1px #aaaaaa solid;
      border-collapse: collapse;
    }

    table th, table td {
      border: 1px #aaaaaa solid;
      padding: 0.2em;
    }

    table th {
      background: #f2f2f2;
      text-align: center;
    }
  </style>
</head>
<body>
EOF

    # Display information about this test run.
    printf $reportFd "<h2>%s</h2>\n", $title;
    printf $reportFd "<p><b>BYTE UNIX Benchmarks (Version %s)</b></p>\n\n",
                     $version;
}


# Display a banner indicating the configuration of the system under test
# to the given file desc.
sub displaySystemHtml {
    my ( $info, $fd ) = @_;

    printf $fd "<h3>Test System Information</h3>\n";
    printf $fd "<p><table>\n";

    # Display basic system info.
    printf $fd "<tr>\n";
    printf $fd "   <td><b>System:</b></td>\n";
    printf $fd "   <td colspan=2>%s: %s</td>\n",
               $info->{'name'}, $info->{'system'};
    printf $fd "</tr><tr>\n";
    printf $fd "   <td><b>OS:</b></td>\n";
    printf $fd "   <td colspan=2>%s -- %s -- %s</td>\n",
               $info->{'os'}, $info->{'osRel'}, $info->{'osVer'};
    printf $fd "</tr><tr>\n";
    printf $fd "   <td><b>Machine:</b></td>\n";
    printf $fd "   <td colspan=2>%s: %s</td>\n",
               $info->{'mach'}, $info->{'platform'};
    printf $fd "</tr><tr>\n";
    printf $fd "   <td><b>Language:</b></td>\n";
    printf $fd "   <td colspan=2>%s</td>\n", $info->{'language'};
    printf $fd "</tr>\n";

    # Get and display details on the CPUs, if possible.
    my $cpus = $info->{'cpus'};
    if (!defined($cpus)) {
        printf $fd "<tr>\n";
        printf $fd "   <td><b>CPUs:</b></td>\n";
        printf $fd "   <td colspan=2>no details available</td>\n";
        printf $fd "</tr>\n";
    } else {
        for (my $i = 0; $i <= $#$cpus; ++$i) {
            printf $fd "<tr>\n";
            if ($i == 0) {
                printf $fd "   <td rowspan=%d><b>CPUs:</b></td>\n", $#$cpus + 1;
            }
            printf $fd "   <td><b>%d:</b></td>\n", $i;
            printf $fd "   <td>%s (%.1f bogomips)<br/>\n",
                        $cpus->[$i]{'model'}, $cpus->[$i]{'bogo'};
            printf $fd "       %s</td>\n", $cpus->[$i]{'flags'};
            printf $fd "</tr>\n";
        }
    }

    # Display graphics hardware info.
    if ($info->{'graphics'}) {
        printf $fd "<tr>\n";
        printf $fd "   <td><b>Graphics:</b></td>\n";
        printf $fd "   <td colspan=2>%s</td>\n", $info->{'graphics'};
        printf $fd "</tr>\n";
    }

    # Display system runlevel, load and usage info.
    printf $fd "<tr>\n";
    printf $fd "   <td><b>Uptime:</b></td>\n";
    printf $fd "   <td colspan=2>%s; runlevel %s</td>\n",
                   $info->{'load'}, $info->{'runlevel'};
    printf $fd "</tr>\n";

    printf $fd "</table></p>\n\n";
}


# Display the test scores from the given set of test results
# for a given category of tests.
# 此子例程用于在 HTML 报告中显示测试系统的基本信息
sub logCatResultsHtml {
    my ( $results, $cat, $fd ) = @_;

    my $numIndex = $results->{'numIndex'}{$cat};
    my $indexed = $results->{'indexed'}{$cat};
    my $iscore = $results->{'index'}{$cat};
    my $full = defined($indexed) && $indexed == $numIndex;

    # If there are no results in this category, just ignore it.
    if (!defined($results->{'numCat'}{$cat}) ||
                            $results->{'numCat'}{$cat} == 0) {
        return;
    }

    # Say the category.  If there are no indexed scores, just say so.
    my $warn = "";
    if (!defined($indexed) || $indexed == 0) {
        $warn = " — no index results available";
    } elsif (!$full) {
        $warn = " — not all index tests were run;" .
                " only a partial index score is available";
    }
    printf $fd "<h4>%s%s</h4>\n", $testCats->{$cat}{'name'}, $warn;

    printf $fd "<p><table width=\"100%%\">\n";

    printf $fd "<tr>\n";
    printf $fd "   <th align=left>Test</th>\n";
    printf $fd "   <th align=right>Score</th>\n";
    printf $fd "   <th align=left>Unit</th>\n";
    printf $fd "   <th align=right>Time</th>\n";
    printf $fd "   <th align=right>Iters.</th>\n";
    printf $fd "   <th align=right>Baseline</th>\n";
    printf $fd "   <th align=right>Index</th>\n";
    printf $fd "</tr>\n";

    # Display the individual test scores.
    foreach my $bench (@{$results->{'list'}}) {
        my $bresult = $results->{$bench};
        next if $bresult->{'cat'} ne $cat;

        printf $fd "<tr>\n";
        printf $fd "   <td><b>%s</b></td>\n", $bresult->{'msg'};
        printf $fd "   <td align=right><tt>%.1f</tt></td>\n",
                   $bresult->{'score'};
        printf $fd "   <td align=left><tt>%s</tt></td>\n",
                   $bresult->{'scorelabel'};
        printf $fd "   <td align=right><tt>%.1f s</tt></td>\n",
                   $bresult->{'time'};
        printf $fd "   <td align=right><tt>%d</tt></td>\n",
                   $bresult->{'iterations'};

        if (defined($bresult->{'index'})) {
            printf $fd "   <td align=right><tt>%.1f</tt></td>\n",
                       $bresult->{'iscore'};
            printf $fd "   <td align=right><tt>%.1f</tt></td>\n",
                       $bresult->{'index'};
        }
        printf $fd "</tr>\n";
    }

    # Display the overall score.
    if (defined($indexed) && $indexed > 0) {
        my $title = $testCats->{$cat}{'name'} . " Index Score";
        if (!$full) {
            $title .= " (Partial Only)";
        }
        printf $fd "<tr>\n";
        printf $fd "   <td colspan=6><b>%s:</b></td>\n", $title;
        printf $fd "   <td align=right><b><tt>%.1f</tt></b></td>\n", $iscore;
        printf $fd "</tr>\n";
    }

    printf $fd "</table></p>\n\n";
}


# Display index scores, if any, for the given run results.
# 在 HTML 报告中显示测试结果的指数分数
sub logResultsHtml {
    my ( $results, $fd ) = @_;

    foreach my $cat (keys(%$testCats)) {
        logCatResultsHtml($results, $cat, $fd);
    }
}


# Dump the given run results into the given report file.
# 在 HTML 报告中总结测试运行的结果
sub summarizeRunHtml {
    my ( $systemInfo, $results, $verbose, $reportFd ) = @_;

    # Display information about this test run.
    my $time = $results->{'end'} - $results->{'start'};
    printf $reportFd "<p><hr/></p>\n";
    printf $reportFd "<h3>Benchmark Run: %s; %s</h3>\n",
           number($systemInfo->{'numCpus'}, "CPU"),
           number($results->{'copies'}, "parallel process", "parallel processes");
    printf $reportFd "<p>Time: %s - %s; %dm %02ds</p>\n",
                     strftime("%H:%M:%S", localtime($results->{'start'})),
                     strftime("%H:%M:%S", localtime($results->{'end'})),
                     int($time / 60), $time % 60;
    printf $reportFd "\n";

    # Display the run scores.
    logResultsHtml($results, $reportFd);
}

# 在 HTML 报告的结尾部分添加一些附加信息，通常是一些法律声明或免责声明
sub runFooterHtml {
    my ( $reportFd ) = @_;

    print $reportFd <<EOF;
<p><hr/></p>
<div><b>No Warranties:</b> This information is provided free of charge and "as
is" without any warranty, condition, or representation of any kind,
either express or implied, including but not limited to, any warranty
respecting non-infringement, and the implied warranties of conditions
of merchantability and fitness for a particular purpose. All logos or
trademarks on this site are the property of their respective owner. In
no event shall the author be liable for any
direct, indirect, special, incidental, consequential or other damages
howsoever caused whether arising in contract, tort, or otherwise,
arising out of or in connection with the use or performance of the
information contained on this web site.</div>
</body>
</html>
EOF
}


############################################################################
# MAIN
############################################################################

# 定义主程序
sub main {
    # 获取命令行参数
    my @args = @_;
    my $params = parseArgs(@args); # 解析命令行参数，得到参数哈希表

    # 设置默认详细程度（verbosity）为 1
    my $verbose = $params->{'verbose'} || 1;

    # 如果设置了迭代次数参数，根据迭代次数设置长短两种迭代次数
    if ($params->{'iterations'}) {
        $longIterCount = $params->{'iterations'};
        $shortIterCount = int(($params->{'iterations'} + 1) / 3);
        $shortIterCount = 1 if ($shortIterCount < 1);
    }

    # 如果未指定具体的基准测试，将默认运行 "index"
    my $tests = $params->{'tests'};
    if ($#$tests < 0) {
        $tests = $index;
    }

    # 创建必要的目录
    my @creatingDirectories = ( ${TMPDIR}, ${RESULTDIR} );
    createDirrectoriesIfNotExists(@creatingDirectories);

    # 运行前检查
    preChecks();

    # 获取系统信息
    my $systemInfo = getSystemInfo();

    # 如果未指定副本数，将默认设置为 1 和系统中的 CPU 数量
    my $copies = $params->{'copies'};
    if (!$copies || scalar(@$copies) == 0) {
        push(@$copies, 1);
        if (defined($systemInfo->{'numCpus'}) && $systemInfo->{'numCpus'} > 1) {
            push(@$copies, $systemInfo->{'numCpus'});
        }
    }

    # 显示程序横幅
    system("cat \"${BINDIR}/unixbench.logo\"");

    # 如果不是静默模式，显示输出目录信息
    if ($verbose > 0) {
        printUsingDirectories();
    }

    # 如果详细程度（verbosity）大于 1，显示要运行的测试
    if ($verbose > 1) {
        printf "\n", join(", ", @$tests);
        printf "Tests to run: %s\n", join(", ", @$tests);
    }

    # 生成唯一的报告文件名和日志文件名
    my $reportFile = logFile($systemInfo);
    my $reportHtml = $reportFile . ".html";
    my $reportCsv = $reportFile . ".csv";
    my $logFile = $reportFile . ".log";

    # 如果定义了 "UB_OUTPUT_CSV" 环境变量并且设置为 "true"，则输出 CSV 文件
    my $ubOutputCsv = $ENV{"UB_OUTPUT_CSV"};
    my $isOutputFormatCsv = defined($ubOutputCsv) && $ubOutputCsv eq "true";
    my $is_csv_header_written = 0;  # 如果写入 CSV，头部只需写入一次

    # 打开日志文件
    open(my $reportFd, ">", $reportFile) || die("Run: can't write to $reportFile\n");

    # 打开 HTML 报告文件
    open(my $reportFd2, ">", $reportHtml) || die("Run: can't write to $reportHtml\n");

    # 如果设置了 CSV 输出，打开 CSV 报告文件
    my $reportFd_Csv;
    if ($isOutputFormatCsv) {
        open($reportFd_Csv, ">", $reportCsv) || die("Run: can't write to $reportCsv\n");
    }

    # 在 HTML 报告文件中输出 BYTE UNIX Benchmarks 版本信息
    printf $reportFd "   BYTE UNIX Benchmarks (Version %s)\n\n", $version;

    # 运行 HTML 报告的头部
    runHeaderHtml($systemInfo, $reportFd2);

    # 输出系统信息
    displaySystem($systemInfo, $reportFd);
    displaySystemHtml($systemInfo, $reportFd2);

    # 对于每个副本数，运行基准测试
    foreach my $c (@$copies) {
        if ($verbose > 1) {
            printf "Run with %s\n", number($c, "copy", "copies");
        }
        
        # 运行基准测试，并将结果输出到 HTML 和 CSV 文件中
        my $results = runTests($tests, $verbose, $logFile, $c);

        # 输出基准测试运行的总结
        summarizeRun($systemInfo, $results, $verbose, $reportFd);

        # 输出 HTML 报告的运行总结
        summarizeRunHtml($systemInfo, $results, $verbose, $reportFd2);

        # 如果设置了 CSV 输出，输出 CSV 文件的头部并写入行数据
        if ($isOutputFormatCsv) {
            if ( $is_csv_header_written == 0 ) {
                summarizeRunCsvHeader($results, $reportFd_Csv);
                $is_csv_header_written = 1;
            }
            summarizeRunCsvRows($results, $reportFd_Csv);
        }
    }

    # 运行 HTML 报告的尾部
    runFooterHtml($reportFd2);

    # 关闭文件
    close($reportFd);
    close($reportFd2);
    if ($isOutputFormatCsv) {
        close($reportFd_Csv);
    }

    # 如果不是静默模式，显示报告内容
    if ($verbose > 0) {
        printf "\n";
        printf  "========================================================================\n";
        system("cat \"$reportFile\"");
    }

    # 返回 0 表示程序成功运行结束
    return 0;
}

# 执行主程序
exit(main(@ARGV));

